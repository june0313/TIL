# Garbage Collection

## Intro
- Full GC가 수행되는 시점에는 해당 JVM에서 처리되지 않는다.

## GC란 무엇인가
쓰레기? 를 효과적으로 정리하는 작업
- 자바에서 쓰레기는 `객체`
- 하나의 `객체`는 메모리를 점유하고 필요하지 않으면 메모리에서 해제 되어야 한다.

## 자바에서 데이터를 처리하기 위한 영역(Runtime Data Area)
Java Virtual Machine Specification : [http://docs.oracle.com/javase/specs/index.html](http://docs.oracle.com/javase/specs/index.html)
- PC 레지스터
- JVM 스택
- 힙
- 메소드 영역
- 런타임 상수 풀
- 네이티브 메소드 스택

이 중에서 GC가 발생하는 부분은 `힙` 영역이다. 나머지 영역은 GC 대상이 아니다.
단순하게 자바의 메모리 영역은 `Heap 메모리`와 `Non-heap 메모리`로 나뉜다.

### Heap 메모리
- 클래스의 인스턴스, 배열이 이 메모리에 쌓인다.
- `공유(shared) 메모리` 라고도 불리며 여러 쓰레드에서 공유하는 데이터들이 저장되는 메모리이다.
- JVM이 시작될 때 생성됨.

### Non-heap 메모리
자바의 내부 처리를 위해 필요한 영역. 주된 영역은 바로 메소드 영역이다.
- 메소드 영역 : 메소드 영역은 모든 JVM스레드에서 공유한다. 이 영역에 저장되는 데이터들은 다음과 같다.
    - 런타임 상수 풀 : 자바 클래스 파일에 포함된 constant_pool에 대한 정보를 실행시에 참조
    - 메소드 데이터
    - 메소드와 생성자 코드
- JVM 스택
    - 스레드가 시작할 때 생성
    - 메소드가 호출되는 정보인 frame이 저장된다.
    - 지역변수, 임시 결과, 메소드 수행과 리턴에 관련된 정보들
- 네이티브 메소드 스택 : Java코드가 아닌 다른 언어로 된 코드들이 실행하게 될 때의 스택 정보(보통은 C)
- PC 레지스터 : 자바 스레드는 각자의 PC(Program Counter)레지스터를 갖는다.

Heap 영역과 메소드 영역은 JVM이 시작될 때 생성된다.

## GC의 원리
가비지 콜렉터(Gargabe Collector)는 다음 역할은 수행한다.
- 메모리 할당
- 사용중인 메모리 인식
- 사용하지 않는 메모리 인식

GC를 해도 더이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면 `OutOfMemoryError`가 발생하여 JVM이 다운될 수도 있다.

힙 영역은 크게 `Young`, `Old`, ~~`Perm`~~ 세 영역으로 나뉜다.
> 이 중 Perm영역은 없는것으로 치자. 이 영역은 거의 사용되지 않는 영역으로 자바 언어 레벨에서 사용하는 영역이 아니기 때문이다.
게다가 JDK 8 부터는 이 영역이 사라졌다.

Young영역은 다시 Eden 및 두개의 Survivor 영역으로 나뉘므로 우리가 고려해야 할 자바의 메모리 영역은 총 4개의 영역으로 나뉜다.
- Eden (Young)
- Survivor 1 (Young)
- Survivor 2 (Young)
- Old

### 객체가 메모리에 할당되는 순서
1. 메모리에 객체가 생성되면 Eden 영역에 객체가 저장된다. 
2. Eden 영역에 데이터가 꽉 차면 Survivor 영역 둘 중 하나에 할당된다. (두개의 Survivor영역 중 한 영역은 반드시 비어있어야 한다.)
3. 할당된 Survivor 영역이 차면 GC가 일아나면서 Eden 영역에 있는 객체와 꽉 찬 Survivor 영역에 있는 객체가 비어있는 Survivor 영역으로 이동한다.
4. Survivor 1과 2를 왔다 갔다 하던 객체들은 Old 영역으로 이동한다.

## GC의 종류
- Minor GC : Young 영역에서 발생하는 GC
- Major GC : Old 영역에서 발생하는 GC

두가지 GC가 어떻게 상호 작용하느냐에 따라 GC 방식에 차이가 나며 성능에도 영향을 준다.