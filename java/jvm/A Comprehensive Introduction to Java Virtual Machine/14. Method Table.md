# Method Table
- 인스턴스 메소드를 참조하는 방법
- 인스턴스 메소드를 호출할 때 사용된다.
- 클래스의 메소드 테이블 참조 방법과 인터페이스의 메소드 테이블 참조 방법에 차이가 있다.

## Example
```java
interface I {
    void bar();
}

class A {
    static void staticMethod() {}
    void foo() {}
}

class B extends A {
    static void staticMethod() {}
    void norf() {}
}

class C extends A implements I{
    void bar() {}
    void foo() {}
}
```
위와 같은 코드가 있을 때 아래 코드에서 클래스 `X`가 `go(A a)` 메서드를 실행한다고 가정하자.
```java
void go (A a) {
    a.foo();
    a.staticMethod();
}
```
go 메서드의 첫 번 째 줄에서 a.foo() 메서드가 호출되는데, 실제 런타임 전에는 인스턴스 a가 A, B, C 클래스 중 어떤 클래스의 인스턴스인지 알 수 없다. 런타임시에 실제로 어떤 메서드를 호출할지를 결정하기 위해 `Method Table`이 필요하다. 이 예에선 클래스별로 3개의 Method Table이 생성된다.

#### 클래스 A의 메서드 테이블
| index | element |
| ----- | ------- |
| 0     | A.foo() |

#### 클래스 B의 메서드 테이블
| index | element  |
| ----- | -------- |
| 0     | A.foo()  |
| 1     | B.norf() |

#### 클래스 C의 메서드 테이블
| index | element |
| ----- | ------- |
| 0     | C.foo() |
| 1     | C.bar() |

메소드 테이블의 element는 실제 메서드의 바이트코드를 가리키는 포인터이다.

JVM은 클래스 자신의 메서드 레퍼런스를 저장하기 전에 슈퍼클래스의 메서드 레퍼런스를 먼저 저장한다.
같은 클래스 안에서는 메서드가 선언된 순서대로 저장한다.

C 클래스의 경우 foo() 메서드보다 bar() 메서드가 먼저 선언되어 있음에도, foo() 메서드가 0번인 이유는 슈퍼클래스 A에서 foo()의 인덱스가 0이기 때문이다.  

여기서 흥미로운점이 있는데, JVM은 C.foo() 혹은 B.foo() method를 호출하기 위해 method table을 탐색하지 않는다는 것이다.
그 이유는 a.foo()를 가리키는 runtime constant pool이 항상 슈퍼클래스의 foo() 메서드의 인덱스와 동일한 0을 가리키기 때문이다. 그래서 타켓 method table이 A 클래스의 것이든 B 클래스의 것이든, C 클래스의 것이든 상관 없이 0번 인덱스를 참조하여 foo() 메소드를 호출한다.

그러나 슈퍼크래스 A가 클래스가 아니라 인터페이스라면 이야기가 달라진다. C 클래스의 경우, A 가 더이상 클래스가 아니므로, A의 메서드 레퍼런스를 저장하지 않고 자기 가진의 메서드 레퍼런스를 저장하게된다. 이 경우 bar() 메서드가 foo() 메서드보다 먼저 선언되었기 때문에, bar()가 0번 인덱스, foo()가 1번 인덱스가 된다.
| index | element |
| ----- | ------- |
| 0     | C.bar() |
| 1     | C.foo() |

이러한 이유로 타입이 인터페이스이면 JVM은 호출할 메서드를 찾기 위해 메서드 테이블을 탐색한다. 그래서 인터페이스가 클래스보다 더 약간 더 느리다. 그러나 그 속도 차이는 아주 미미하다.

go() 메서드의 두번째 줄에서는 static 메서드인 `a.staticMethod()`를 호출하고 있는데, 이는 메서드 테이블이 필요없다. static method의 참조는 컴파일 타입에 결정되기 때문이다. 기본적으로 메서드 테이블은 인스턴스 메서드의 참조 정보만 저장한다.