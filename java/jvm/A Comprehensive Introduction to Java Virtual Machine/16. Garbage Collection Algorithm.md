#  가비지 컬렉션 알고리즘

## GC의 도전 과제들

1. 더 이상 사용되지 않는(abandoned) 객체를 어떻게 식별 할 것인가?

2. 애플리케이션이 정지(pause)되는 시간을 어떻게 줄일것인가?

    

## 죽은 객체를 식별하고 메모리 반환하기

### Mark and Sweep

- 참조 가능한 모든 객체를 식별한다(mark)
- GC root 로부터 객체의 그래프를 따라 참조 가능한 객체를 찾는다.
- 그렇게 따라갔을 때 도달 불가능한 객체들이 죽은(Dead) 객체들이다.
- Sweep 단계에서는 mark되지 않은 객체의 메모리를 해제한다.
- 이러한 GC가 일어나는 동안에는 애플리케이션이 멈춘다.
- 애플리케이션이 멈추는 이유는, 만약 Sweep 단계에서 새로운 객체가 성생되면 아직 mark되지 않았으므로 메모리가 헤제되는 문제가 발생하기 때문이다.
- 메모리가 부분 부분 할당 되면서 메모리 파편화가 발생하는 단점이 있다.

### Mark-Sweep-Compact

- Mark and Sweep 후 Compact 과정을 거쳐 파편화된 메모리를 정리한다.
- Compact 단계에서는 살아있는 객체들을 메모리의 앞쪽으로 모은다.(재배치)
- 파편화 문제가 없고, 크키가 큰 사이즈의 객체도 할당할 수 있게 된다.
- 애플리케이션의 정지 시간은 증가하게 된다.

### Mark and Copy

- Mark-Sweep-Compact와 비슷한 알고리즘
- Heap을 두개의 영역으로 나누어서 관리(여기서는 단순히 A, B라고 칭함)
- A 영역은 사용중인 객체들이 있고 B영역은 비워져있다.
- GC가 수행되면 A에 있던 살아있는 객체들이 B영역으로 재배치(복사) 하고 A 영역을 비운다.( Scavenge)
- 살아남은 객체를 B 영역으로 복사할 때는 한 쪽 방향부터 연속적으로 하기 때문에 파편화가 발생하지 않는다.
- Mark와 Copy가 동시에 수행될 수 있기 때문에 애플리케이션의 중지 시간이 줄어든다.