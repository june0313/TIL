# 아키텍트의 진화(아키텍트 역할의 변화)
변화의 속도가 빨라지고 아키텍처가 수용할 수 있는 환경이 유연해지면서 아키텍트의 역할 또한 변하고 있음

## 1. 정확하지 않은 비교
- 아키텍트의 역할을 한마디로 정의 하기는 쉽지 않다.
- 아키텍트의 역할에 대한 오해가 많다.
- IT 산업은 아직 성숙하지 않았다. 우리의 직업을 설명하기 위해 다른 산업에서 직업명을 빌려 왔는데, 소프트웨어 엔지니어, 아키텍트가 그 예이다. 하지만 실제로는 엔지니어도 아니고 아키텍트(건축가)도 아니다.
- **어떤 것이 좋은지 판단하는데 있어 우리는 아직 모르는게 너무 많다. (IT의 역사가 오래되지 않아서)**
- 아키텍트의 의미를 우리의 입장과 관점에서 재정의 해야한다.

## 2. 아키텍트에 대한 진화적 관점
- 아키텍트는 처음부터 완벽한 제품을 만드려고 생각해선 안된다.
- 추가 학습을 통해 적합한 시스템이 생성되고 지속해서 성장할 수 있는 프레임워크를 만드는데 보탬이 되어야 한다.
- 아키텍트의 역할은 건축가 보다는 `도시 설계자`에 가깝다.
- 아키텍트는 모든 사태에 대해 미리 계획하기 보다는 변화를 받아들이도록 해야한다.
- 방향 자체는 개괄적으로 설정하되 특정 겨우의 세부 구현에 대해서만 매우 구체적으로 관여해야 한다.

## 3. 구역화(Zoning)
- 아키텍트는 구역(zone) 내의 일보다는 구역과 구역 사이에서 발생하는 일을 더 걱정해야 한다.
- 즉 서비스간 통신 방법이나, 시스템의 전반적인 상태를 적절히 모니터링 하는데 더 많은 시간을 할애해야 한다는 뜻이다.

## 4. 원칙적인 접근법(A Principled Approach)
### 전략적 목표
- 전략적 목표는 회사가 나아가고 있는 방향, 고객만족을 위해 어떻게 해야할지에 대해 언급해야 한다.
- 전략적 목표는 조직이 지향하는 바와 일치해야 한다.

### 원칙
- 더 큰 목표를 위해 해야 할 일을 정렬하는 규칙
- 예를 들어, 조직의 전략적 목표가 `여러 국가에서 공격적으로 제품을 성장시키는 것` 이라면? -> `시스템 전체가 지역적으로 배포될 수 있도록 이식 가능해야 한다`와 같은 원칙을 만들 수 있다.
- 원칙의 개수는 10개 미만인 것이 좋다.(원칙이 많을수록 서로 겹치거나 모순될 가능성이 커짐)

### 실천사항
- 원칙을 실행하는 방법. 업무 수행을 위한 자세하고도 실질적인 지침
- 대개 기술 명세적이고 어떤 개발자도 이해할 수 있도록 충분히 구체적이어야 한다.
- ex)
    - `모든 로그 데이텅의 중앙 수집이 필요하다`
    - `표준 통합 스타일은 HTTP/REST 이다.`
- 기술적 특성으로 인해 실천사항은 원칙보다 더 자주 변경됨
- ex) 원칙 : `배포 팀이 시스템의 모든 생명주기를 통제해야 한다`
    - 실천사항 1 : 모든 서비스가 서로 격리된 AWS 계정을 통해 배포되어야 한다.
    - 실천사항 2 : 자원에 대한 셀프 서비스 관리를 제공한다.
    - 실천사항 3 : 다른 팀과 격리되어야 한다.

### 원칙과 실천사항의 결합
- 누군가의 원칙이 누군가의 실천사항이 될 수 있음
- 작은 그룹에서는 원칙과 실천사항을 결합하는 일이 문제되지 않는다
- 큰 조직의 경우에는 공통된 원칙을 지향하면서도 팀별로 기술과 실천사항이 다를 수 있다.

## 5. 필수 기준 (원칙적인 접근법에대한 개념들을 구체화 하기위한 도구)
- 자율적인 수명주기를 가지면서도 함께 협업하는 수많은 작은 부품으로 구성된 응집력 있는 시스템이 되어야 한다. 
- 거시적 시각을 잃지 않으면서도 개별 마이크로서비스 간의 자율성 최적화와 관련된 균형을 찾아야 한다.
- 이를 위해서는 각 서비스가 가져야 할 명확한 속성을 정의해야한다.

### 모니터링
- 서비스간 경계를 넘어 시스템 상태를 일관되게 살펴볼 수 있어야 한다.
- 모든 서비스가 자신의 상태와 일반적인 모니터링 관련 지표(metric)을 동일한 방식으로 전송하는 것이 좋다.
- 어떤 것을 선택하든 표준을 유지해야 한다.
- 로깅도 같은 범주에 속하며 한 곳에서 수집되도록 해야한다.

### 인터페이스
- 서비스 간 인터페이스 기술의 개수는 가능한 최소로 유지하는 편이 좋다.

### 아키텍처의 안정성
- 오동작 하는 하나의 서비스가 전체 시스템을 다운시키면 안된다.
- 서킷 브레이커를 사용할 수도 있다.
- 응답 코드가 규약대로 동작하는 것도 중요하다.

## 6. 코드를 통한 통제
- 여러 사람들에게 위와같은 지침을 따르게 하는 것은 어렵다. 
- Example code 와 서비스 템플릿과 같이 코드를 통해 통제하는 것이 효과적이다.

### Example code
- 문서를 기록하는 유용하지만 개발자들은 실행되는 코드를 더 선호한다.
- 실제 사용하는 서비스에 대한 example code를 제공한다.

### 맞춤형 서비스 템플릿
- 모든 개발자가 따를 수 있는 지침의 대부분을 약간의 노력만으로 손쉽게 만들 수 있도록 해야한다.

## 7. 기술 부채
- 조직에 따라 아키텍트가 관대한 지침을 제공하고 팀 스스로 부채를 찾아내서 상환하는 방법을 결정 할 수도 있음
- 또 다른 조직에서는 아키텍트가 정기적으로 검토되는 부채 로그를 관리하면서 더욱 체계화할 필요가 있다.

## 8. 예외 처리
- 예외 상황이 발생하면 나중에 참조 할 수 있도록 기록 해두는 것이 좋다.
- 충분히 많은 예외가 발견된다면 결과적으로 원칙과 실천사항을 변경하는 것이 타당할 수도 있다.

## 9. 중앙에서의 거번넌스와 지휘
- 아키텍트의 업무 중 하나는 기술 `거버넌스`
- 우리가 구축하는 결과물(시스템)이 기술 비전과 일치함을 보장하고, 필요한 경우 비전을 진화시켜야 한다.
- 거버넌스 그룹 활동을 통해 업무를 공유하고 기술 비전을 형성하자.

## 10. 팀 만들기
- 기술 리더의 역할은 사람들이 스스로 비전을 이해하도록 그들의 성장을 돕고, 비전을 결정하고 구현하는데 적극적으로 참여할 수 있도록 만드는 것
- 거대한 모놀리식 시스템에서는 사람들이 성장하고 무엇인가를 소유할 기회가 거의 없음
- 마이크로서비스에서는 독립적인 수명주기를 가진 수 많은 자율적인 코드베이스를 가질 수 있다.
 
